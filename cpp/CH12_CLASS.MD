##CH12: 类 CLASS
<strong>PART3导言</strong>: 类, 是CPP中能够为解决问题而自定义的一种ADT, 设计良好的类能够像内置类型一样容易使用.

类定义了数据成员(对象的状态)与函数成员(作用于状态的操作), 通过类, 可以将(类的具体)实现与接口(类支持的操作)分离, 这种分离减少了编程的冗长乏味和容易出错的繁琐工作.

类是一种ADT, 而ADT将数据和操作视为一个单元, 通过调用类的接口, 我们可以考虑类该做的事情, 而不需要细节的设计. ADT是OOP和泛型编程的基础.

CH12涵盖的内容有: 类作用域, 构造函数, this指针, 以及, 友元, 可变成员, 静态成员.

####12.1 类的定义和声明
CPP早期版本被命名为"C with Classes", 可见, 类机制的中心作用(附例: "[Sales_item.cpp](file:./Sales_item.cpp)"). 最简单来说, 类定义了一个新的类型和新的作用域.

#####12.1.1 类定义: 扼要重述
所有类成员必须在类内部声明(注意,不是定义); 构造函数是一个函数, 是一个特殊的与类同名的成员函数, 用于给数据成员设置适当的初始值, 一般使用一个跟在构造函数形参列表之后的初始化列表进行初始化.

类内部, 成员函数声明是必须的, 而定义是可选的, 默认地, 在类内部定义的函数为inline; 在类外定义成员函数, 需在要定义的函数名前加上作用域操作符("::"); 成员函数有一个附加的隐含实参(即"*this"), 用于将函数绑定到调用函数的对象上.

将关键字const加到形参表之后, 该函数就被声明为常量, 该成员函数就不能改变其所操作对象的数据成员了; 这个const必须同时出现在声明和定义中, 否则, 有编译错误.

#####12.1.2 数据抽象和封装
数据抽象, 简单说来, 是一种依赖于<strong>接口和实现分离</strong>(要不然,接口和实现"你中有我我中有你")的编程技术.

封装, 是将低层次元素组合起来, 形成新的高层次实体的技术(如,函数); <strong>封装</strong>之后的自然而然的结果就是<strong>数据抽象</strong>了. 我们可以调用函数, 但是函数细节被隐藏了, 我们不能访问它的执行语句, 同样地, 对于类这种ADT来说也是如此的, 不过类的访问可以通过访问标号来控制而函数不能.

1.访问标号实施抽象和封装: 标号的作用方式是向后作用直到类定义体的右花括号, 而在第一个访问标号之前和类的左花括号之后, class类默认是private的, struct默认是public的; 

2.编程角色的不同类别: 类的用户一般指要在编程中使用到这些类的程序员, 而程序的用户指程序的(普通)使用者.

数据抽象和封装的好处: 1.避免类内部的一些错误, 2.便于程序的开发维护迭代.

#####12.1.3 类定义, 更多..
1.同一类型的多个数据成员,

2.使用类型别名来简化类(typedef),

3.成员函数可被重载,

4.定义重载成员函数,

5.显式指定inline成员函数: 类内部<strong><u>定义</u></strong>的成员函数, 会被默认地视作inline函数; inline关键字的使用, 在声明和定义时, 只出现一次即可.

(附例: "[Screen.cpp](file:./Screen.cpp)")

#####12.1.4 类声明, 类定义
一旦遇到右花括号, 类的定义就结束了; 类一旦定义了, 我们就知道了所有的类成员, 及存储该类的对象所需的存储空间.

一个源文件中, 一个类只能被定义一次. 使用头文件保护符(header guard), 可以保证头文件在同一文件中不被包含多次, 类定义也就只出现一次.

声明一个类而不马上定义它, 就是类的前向声明(forward declaration); 在声明之后, 定义之前, 一个类是不完全类型(incomplete type), 在此情况下, 该类只能被有限地使用: 只能定义指向该类的指针和引用, 或者声明(非定义)使用该类作为形参或返回类型的函数, 不能用该类创建类对象.

类的前向声明一般用于编写相互依赖的类.

#####12.1.5 类对象
定义类时不会进行存储的分配, 定义对象时才会进行存储的分配.

1.定义类类型的对象: "class/struct Sales_item item1" 是C继承而来的定义对象的方式, 等价于无class/struct的版本;

2.类定义以分号结束: 分号是必需的是因为在类定义之后可以接一个<u>对象定义列表</u>, 如, "class Sales_item { /\* ... \*/ } accum, trans;", 而一般情况下我们不这样做.

####12.2 隐含的this指针
 

####12.3 类作用域
略.

####12.4 构造函数
略.

####12.5 友元
略.

####12.6 static类成员
略.

####12.7 小结
略.