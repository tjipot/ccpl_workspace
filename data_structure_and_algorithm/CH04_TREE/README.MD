##CH04: 树 Tree
对于大量的数据输入, 链表的线性访问时间太慢了, 二叉查找树(树的一种)这种ADT使得大部分的操作时间平均为O(logN);

树的应用有操作系统的文件系统, 及计算算术表达式的值, 执行O(logN)的搜索操作, 等.

####4.1 预备知识
树是一些节点的集合;

树的概念1: 节点, 根, 子树, 有向边, 儿子, 父亲, 树叶, 兄弟, 祖父, 孙子;

树的概念2: 路径, 长, 深度, 高, 祖先(Ancestor), 后裔(Descendant), 真祖先, 真后裔.

4.1.1 树的实现:

树的实现的基础是节点, 节点的体现方式为结构体: 数据+儿子指针+兄弟指针("[tree.c](file:./tree.c)");

4.1.2 树的遍历及应用:

目录结构: 先序遍历(preorder traversal), 后序遍历(postorder), 中序遍历(midorder);

####4.2 二叉树
二叉树的每个节点都不能有多于两个的儿子, 一般用链表来实现二叉树("[binary_tree.c](file:./binary_tree.c)");

<strong>4.2.2 表达式树</strong>: 二叉树的用处之一是编译器设计领域, 此处, 二叉树就变成了表达式树(expression tree); 表达式树的树叶是操作数(operand), 其它节点为操作符(operator); 这里是简单的情况, 也有的操作符是一元的, 或三元的

####4.3 二叉查找树
二叉树的另一个用处是查找, 这里的假设是每个节点被指定一个关键字值(假设是整数且互异);

使<u>二叉树</u>成为<u>二叉查找树</u>的条件是, 树中的每个节点X, 它的<u>左子树</u>中所有关键字值<u>小于X</u>的关键字值, 它的<u>右子树</u>中所有关键字值<u>大于X</u>的关键字值;

4.3.1 MakeEmpty
4.3.2 Find
4.3.3 FindMin和FindMax
4.3.4 Insert
4.3.5 Delete
4.3.6 平均情形分析: 略.

####4.4 AVL树
<u>AVL树</u>(Adelson-Veleskii和Landis)是带有<u>平衡条件</u>的<u>二叉查找树</u>, 这个平衡条件必须要容易保持, 且必须保证树的深度是O(logN); 最简单的想法就是左右子树具有相同的高度(这满足了平衡条件, 但这种想法并不满足树深为O(logN)的条件);

一棵AVL树是其<u>每个节点</u>的左子树和右子树的高度<u>最多差1</u>的二叉查找树("[avl_tree.h](file:./avl_tree.h)"和"[avl_tree.c](file:./avl_tree.c)");

<u>旋转(rotation)</u>: AVL树的所有操作都可以在O(logN)内完成, 但除了插入操作(假设懒惰删除), 因为当进行插入操作时, 我们会更新通向根节点路径上的所有节点的平衡信息, 而更新之后, AVL树可能就没有了平衡特性了, 我们可以通过对树进行简单的修正来做到平衡, 也即, 旋转; 旋转依复杂程度, 分为单旋转(single)/双旋转(double);

####4.5 伸展树 Splay Tree
<u>摊还(amortized)</u>: M次操作的序列的总最坏情形运行时间为O(MF(N))时, 就说它的摊还运行时间为O(F(N));

<u>伸展树(splay tree)</u>保证从空树开始任意连续M次对树的操作最多花费O(MlogN)时间, 故伸展树每次操作的摊还代价是O(logN);

<u>伸展树</u>存在必要性的<u>背景</u>: 即使二叉查找树发生一次O(N)的操作并不要紧, 但是如果累计起来, 一直是O(N)的操作, 那就要紧了(M*O(N)), 故伸展树的O(logN)的保证就很有价值了;

<u>伸展树</u>的<u>基本想法</u>是, 当一个节点被访问后, 它就会经过一系列的AVL树的旋转, 被放到root上; 如果这个节点很深, 那么, 这条路径上也有一些很深的节点, 通过旋转重新构造后, 对这些节点的访问时间都减少了;

实际上, 在许多应用中个, 当一个节点被访问之后, 它往往还会再被访问到; 伸展树节点不需要保留高度或平衡信息, 这也节省了空间和简化了代码(在某种程度上);

####4.6 树的遍历
递归: 访问每个节点+条件判断;

中序遍历: 先左子树再节点再右子树, 如: 打印每个节点的值(即, 从小到大输出了一遍);

后序遍历: 先处理两个子树, 再处理节点, 如: 算某个节点的高度(得先知道俩子树的高度);

先序遍历: 节点再俩儿子之前处理, 如: 利用节点深度标志每一个节点;

以上三种遍历方法的共同点都是<u>先处理NULL</u>的情形, 然后才是其余的工作, 但还有一种遍历方法, 是层序遍历(level-order traversal);

<u>层序遍历</u>的所有深度为D的节点要在深度为D+1的节点之前进行处理, 它不是递归(栈)的, 它用的是队列.

####4.7 B树
迄今为止, 看到的查找树都是二叉树, 但还有一种不是二叉树的查找树, 叫<u>B树</u>(Btree, 节点有两个以上的儿子); 阶是B树的一个属性, 阶为M的B树具有以下特性:

* 树的根或者是一树叶, 或者其儿子数在2和M之间(因为阶为M);
* 除根外, 所有非树叶的节点的<u>儿子数</u>在M/2(ceiling)和M之间;
* 所有树叶都在同一深度上.

此外, B树的所有数据都<u>存储在树叶</u>上; <u>每个内部节点</u>上都有指向该结点各儿子的指针<u>P1, P2, ..., PM</u>和分别代表在子树<u>P2, ..., PM</u>中可以发现的最小关键字的值<u>k1, k2, ..., k(M-1)</u>; 如果, 指针是NULL的, 其对应的ki则是未定义的;

对任意节点, 它的子树Pk中的所有关键字值都小于子树P(k+1)的.

####4.8 小结
<u>表达式树</u>是更一般结构(即分析树(parse tree))的一个小例子, 分析树是编译器设计中的核心数据结构;

<u>查找树</u>几乎支持所有有用的操作, 其<u>对数平均开销</u>很小; 查找树的<u>非递归实现</u>会快一些, 但递归实现更讲究, 更精彩, 而且易于理解和排错; <u>查找树的问题</u>在于它的性能严重依赖输入, 而输入却是随机的, 运行时间显著增加后, 查找树会成为<u>昂贵的链表</u>;

<strong>防止上述坏情形, 我们有了一下几个方法</strong>:

<u>AVL树</u>要求<u>所有节点</u>的左右子树高度差最多是1(保证了树严重不平衡后的深度问题); AVL树中, 所有<u>不改变树的操作</u>都可以使用标准二叉查找树的程序, <u>改变树的操作</u>必须将树恢复, 于是, 我们又有了旋转(rotation);

<u>伸展树</u>(splay tree)的节点可以达到任意的深度, 但在每次访问之后, 树会被调整; 它的实际效果是, 任意连续M次操作花费O(MlogN)时间, 它与平衡树的花费相同;

B树是<u>平衡M-路树</u>(不是二叉了), 能很好地匹配磁盘; 它的特殊情形是2-3树, 它是实现平衡查找树的另一种常用方法;

实践中, 所有平衡树的方案都不如简单的二叉查找树省时(差一个常数因子), 但也是可以接受的;

通过将一些元素插入到查找树然后执行一次中序遍历, 我们会得到排序过的元素, 这给出排序的一种O(NlogN)的算法, 如果使用任何成熟的查找树, 它都是最坏情形的界了.








































