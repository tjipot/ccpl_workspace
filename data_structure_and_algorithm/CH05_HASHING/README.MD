##CH05: 散列 HASHING
<u>散列表</u>(Hash Table)也是一种编排基本数据结构的ADT, 以常数时间实现Insert, Find和Delete操作, 但那些需要元素间任何排序信息的操作不会得到有效支持;

散列的基本思路是: 将要保存的数据"打散"开去, "均匀"保存在有限的存储空间中, 进而同时降低读取所需的时间. "打散"数据要用到<u>散列函数</u>, 散列表的实现方式可以是数组和链表的组合, 解决冲突的方法可以是分离链接法和开放定址法.

####5.1 一般想法
将<u>元素</u>均匀映射到<u>合适的单元</u>中去, 这个映射就是<u>散列函数</u>(hash function); 它应该运算简单而且保证任何不同的关键字能映射到不同的单元, 这是理想的情况, 因为单元数目是有限的, 而且关键字也是用不完的;

散列的基本解决方案是: 1.选取散列函数, 2.发生冲突(collision, 关键字值散列到同一个值)时怎么做, 3.及如何确定散列表的大小.

####5.2 散列函数
完成散列方案的第一步: "1.选取散列函数";

略.

####5.3 分离链接法 Separate Chaining
背景: 两个元素值散列之后可能会有相同的散列值, 要<u>解决这个冲突</u>, 分离链接就是将散列到同一个值的所有元素保留到该值所属的链表中; 如果有更多的相同值元素, 就在这个链表中添加链表node就行.

####5.4 开放定址法 Open Addressing Hashing
<u>开放定址</u>是一种不用链表解决冲突(散列值相同)的方法, 总纲思路是将发生冲突的元素放到另外的单元中去(或, 直到找出空单元为止), 而其中另寻单元的算法是某函数F, 那么开放定址的方法就用到两个函数来实现散列这种ADT了: HASH函数和F函数;

<u>F函数</u>: 通常有三种另寻单元(解决冲突)的方法, 为<u>1.线性探测法</u>, <u>2.平方探测法</u>和<u>3.双散列</u>.

####5.5 再散列 Rehashing
作为开放定址的补充, <u>再散列</u>是对开放定址表中的元素过多导致的操作时间过长及insert失败情况的优化, 总体思路是将原先的表扩容(新的大小), 然后再次进行散列(新的散列函数).

####5.6 可扩散列 Extendible Hashing
可扩散列主要解决处理的数据量太大以至于装不进内存的情况, 此时, 主要考虑的是检索数据所需的磁盘存取次数;

<u>可扩散列</u>允许用两次磁盘访问执行一次find操作, 插入操作也需要很少的磁盘访问, 而不是因为冲突去访问多个磁盘区块, 或因表太满时执行了再散列而耗去O(N)磁盘访问的时间(N个元素).

####5.7 小结
<strong>装填因子</strong>:

1.<u>分离链接法</u>应接近于1;

2.<u>开放定址法</u>不应该超过0.5;

3.<u>再散列运算</u>可以通过增长或收缩表实现散列, 这样就保持了合理的装填因子.

<strong>散列的应用</strong>: 

1.编译器中用<u>散列表</u>跟踪源代码中变量的声明, 此数据结构叫<u>符号表</u>(symbol table);

2.节点是实际名字而不是数字的任何<u>图论问题</u>;

3.为游戏编制的程序: 同样的位置再出现, 程序通过简单的移动变换来避免昂贵的计算, 游戏程序的这种特点叫<u>变换表</u>(transposition table);

4.在线<u>拼写检验程序</u>: 如果<u>错拼检测</u>(与纠正错误相比)更重要, 那么整个字典可以被<u>预先散列</u>, 写好的单词可以在常数时间内被检测出结果; 散列表很适合这工作, 因为以字母<u>顺序</u>来排列单词并不重要.