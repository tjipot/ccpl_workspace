##CH07: 排序 Sorting
数组是一种基本的数据结构, 和链表一样, 都是线性的; 对数组进行排序主要指对数组里的数值类型数据进行排序;

字符串是一个字符数组, 对字符数组变量名直接调用时, C语言的编译器会知道输出一整个字符串, 虽都是数组类型, 整数数组却没有编译器的"特殊照顾"(在这之前, 这点让我很难解);

* 简单排序, Simplesort;
* 冒泡排序, Bubblesort;
* 插入排序, Insertsort;
* 选择排序, Selectsort;
* 归并排序, Mergesort.

这章主要讲解元素的数组排序问题, 将用到大O, 大Ω等算法时间概念.

(旧金山大学的数据结构和算法可视化[网页](http://www.cs.usfca.edu/~galles/visualization/Algorithms.html))

####7.1 预备知识
关于<u>数组排序</u>: 每个算法的基本元素是<u>一个数组</u>和包含<u>元素个数的整数</u>, 按照C的约定, 所有的排序, 数据都将在<u>位置0</u>处开始;

<u>假设</u>, N是传递到要排序例程中的元素个数; <u>再假设</u>, "<"和">"运算符存在, 除赋值运算符("=")外, 这两种运算是仅有的允许对输入数据进行的操作, 在这些条件下的排序称作<u>基于比较的排序</u>(comparison-based sorting).

####7.2 插入排序 Insertsort
从数组的第二个元素开始, 一个一个添加到正在排序的序列中, 详见代码("[insert_sort.c](file:./insert_sort.c)")注释;

Insert sort为O(N^2);

####7.3 一些下界(简单排序算法的)
略: 逆序数;

定理7.1: N个互异数的数组的平均逆序数是N(N-1)/4;

定理7.2: 通过交换相邻元素进行排序的任何算法平均需要Ω(N^2)时间.

####7.4 希尔排序 Shellsort
<u>希尔排序</u>通过比较相距一定间隔的元素来工作, 各趟比较所用的距离随着算法的进行而减小, 直到只比较相邻元素的最后一趟为止(故也称作<u>缩小增量排序</u>(diminishing increment sort));

详见代码"[shell_sort.c](file:./shell_sort.c)".

####7.5 堆排序 Heapsort
<u>优先队列</u>可以用于花费O(NlogN)时间的排序, 基于该想法(指优先队列)的算法叫做<u>堆排序</u>;

<u>实现方法1</u>: 对一个<u>堆A</u>进行deleteMin操作, 将得到的元素放入到另外一个<u>数组B</u>当中; 不断这样操作, 直到堆A中没有元素了, 而数组B就是"排好序"了的数组了; 这其中, deleteMin操作花费O(logN), 而有N个元素, 故总共时间为O(NlogN);

<u>实现方法2</u>: 如果要节省空间, 可以将删除的元素放到堆中最后的一个单元中, 以此类推, 在最后一次deleteMin后, 得到的数组将以<u>递减的顺序</u>包含这些元素; 如果用max堆, 那么得到的数组就是升序的"正常"数组了.

####7.6 归并排序 Mergesort
归并排序的基本操作是合并两个已排序的表, 如已排序的数组A和B(及计数器Aindex和Bindex), 以及放置结果的数组C(及计数器Cindex); 但前置的排序阶段, 我们<u>递归地</u>将前半部分和后半部分的数据各自归并排序, 然后各自地合并, 直到整个数组排序完成; 详见代码"[merge_sort.c](file:./merge_sort.c)";

归并排序是经典的<u>分治策略(divide and conquer)</u>.

####7.7 快速排序 Quicksort
<u>快速排序</u>也是一种分治的递归算法(归并也是), 快速排序的关键在于<u>枢纽元(pivot)</u>的选取, 详见代码"[quick_sort.c](file:./quick_sort.c)";

快速排序平均O(NlogN), 最坏O(N^2).

####7.8 大型结构排序
对所有算法来说, 基本的操作就是交换, 如果交换的结构实际上很大, 那么这个交换就是非常<u>昂贵</u>的一个操作了; 在这种情况下, 实际的解法是让输入数组包含<u>指向结构的指针</u>, 然后我们通过比较指针指向的关键字, 对指针进行"排序"; 这种<u>数据运动</u>的方式, 我们称为<u>间接排序</u>(indirect sorting).

####7.9 排序的一般下界
笔记: 略.

####7.10 桶式排序 Bucketsort
桶式排序利用了序列中的一些<u>额外信息</u>(见后讲解), 如输入数据A1, A2, ..., An必须只由小于<u>M</u>的正整数组成(额外信息), 那么我们使用一个元素个数为M的数组count(全部元素初始化为0), 数组的M个单元称为<u>桶</u>: 当读Ai时, count[Ai]置1, 当所有数据读入后, 打印出所有内容为1的桶, 即排好序的序列;

桶式排序用时O(M+N).

####7.11 外部排序 External Sorting
外部排序: 由于数据量太大而不能在主存中而必须在磁盘(或磁带)上完成的排序;

笔记: 略.

####7.12 小结
笔记: 略.


